// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=addOnMessageReceivedListener_e6729a5ade
ROOST_METHOD_SIG_HASH=addOnMessageReceivedListener_8103def18b

================================VULNERABILITIES================================
Vulnerability: Insecure Direct Object References (IDOR) / CWE-639
Issue: The code snippet suggests that messages can be received and processed. If object references (e.g., message IDs) are not properly secured, an attacker might manipulate these references to access unauthorized data.
Solution: Implement access control checks and indirect object references. Use a mapping table for direct references exposed to users, ensuring they only reference objects they are authorized to access.

Vulnerability: Improper Input Validation / CWE-20
Issue: The method 'addOnMessageReceivedListener' does not validate the input before adding the listener. An attacker could potentially register a malicious listener.
Solution: Validate the input before using it. Ensure that the listener adheres to expected types and behaviors, and reject any input that does not meet these criteria.

Vulnerability: Sensitive Data Exposure / CWE-359
Issue: The code may expose sensitive message content or user information if proper security controls like encryption are not implemented.
Solution: Ensure that sensitive data is encrypted in transit and at rest. Use secure communication protocols like HTTPS and apply encryption standards such as AES.

Vulnerability: Logging Sensitive Information / CWE-532
Issue: The code includes a 'Logger' utility which might log sensitive information if not properly configured, leading to information leakage.
Solution: Configure logging to exclude sensitive information. Use sanitization methods to strip out any potentially sensitive data before it is logged.

Vulnerability: Use of Hard-coded Credentials / CWE-798
Issue: The code references a 'SQLiteManager', which may use hard-coded credentials for database access, posing a risk if credentials are compromised.
Solution: Remove any hard-coded credentials. Utilize a secure method of storing and accessing credentials, such as environment variables or a secure credentials manager.

Vulnerability: SQL Injection / CWE-89
Issue: The interaction with 'SQLiteManager' may be vulnerable to SQL injection if inputs are not properly sanitized before being used in SQL queries.
Solution: Use prepared statements with parameterized queries to prevent SQL injection. Ensure all user-supplied input is sanitized before including it in SQL commands.

Vulnerability: Inadequate Encryption Strength / CWE-326
Issue: If encryption is used but is not strong enough, it might be vulnerable to decryption by attackers.
Solution: Use strong, industry-standard algorithms with appropriate key lengths. Regularly review and update encryption methods to align with current best practices.

Vulnerability: Insecure Dependency Management / CWE-829
Issue: The code imports third-party libraries which may contain vulnerabilities if they are not kept up to date or are not securely integrated.
Solution: Regularly update dependencies to their latest secure versions. Employ tools to track vulnerabilities in third-party libraries and assess their trustworthiness before integrating them.

================================================================================
Scenario 1: Valid listener addition

Details:
  TestName: addValidOnMessageReceivedListener
  Description: This test checks if a valid listener can be added to the onMessageReceivedListeners collection.
Execution:
  Arrange: Create a mock BiConsumer<String, Message> listener.
  Act: Invoke the addOnMessageReceivedListener method with the mock listener.
  Assert: Confirm that the listener has been added to the onMessageReceivedListeners collection.
Validation:
  The assertion verifies that the listener is present in the collection, ensuring that the method correctly handles valid listener additions. This test is significant because it validates that the core functionality of adding listeners is working as expected.

Scenario 2: Null listener handling

Details:
  TestName: ignoreNullOnMessageReceivedListener
  Description: This test verifies that a null listener is not added to the onMessageReceivedListeners collection.
Execution:
  Arrange: Set the listener to null.
  Act: Invoke the addOnMessageReceivedListener method with a null listener.
  Assert: Assert that the onMessageReceivedListeners collection size remains unchanged.
Validation:
  The assertion ensures that the method does not add null listeners, which could lead to NullPointerExceptions during event notifications. This test is significant to confirm the robustness of the listener management mechanism.

Scenario 3: Listener addition when the collection is empty

Details:
  TestName: addListenerWhenCollectionIsEmpty
  Description: This test ensures that a listener can be added when the onMessageReceivedListeners collection is initially empty.
Execution:
  Arrange: Ensure the onMessageReceivedListeners collection is empty. Create a mock BiConsumer<String, Message> listener.
  Act: Invoke the addOnMessageReceivedListener method with the mock listener.
  Assert: Assert that the onMessageReceivedListeners collection contains exactly one listener after the method call.
Validation:
  The assertion checks that the method works as expected even when the listeners collection starts empty, proving that the method can handle the initialization case correctly.

Scenario 4: Adding multiple listeners

Details:
  TestName: addMultipleOnMessageReceivedListeners
  Description: This test verifies that multiple listeners can be added to the onMessageReceivedListeners collection without any issues.
Execution:
  Arrange: Create multiple mock BiConsumer<String, Message> listeners.
  Act: Invoke the addOnMessageReceivedListener method with each of the mock listeners.
  Assert: Assert that all listeners are present in the onMessageReceivedListeners collection and that the collection size matches the number of added listeners.
Validation:
  The assertion ensures that the method can handle multiple additions, which is significant for scenarios where multiple components need to listen to message received events.

Scenario 5: Adding the same listener multiple times

Details:
  TestName: addSameListenerMultipleTimes
  Description: This test checks the behavior of the addOnMessageReceivedListener method when the same listener is added more than once.
Execution:
  Arrange: Create a mock BiConsumer<String, Message> listener.
  Act: Invoke the addOnMessageReceivedListener method multiple times with the same listener.
  Assert: Assert that the onMessageReceivedListeners collection contains multiple instances of the same listener.
Validation:
  The assertion will verify that the method allows duplicate listeners to be added. This test is significant because it checks for idempotency and determines whether the method treats the listener instances as unique or not.
*/

// ********RoostGPT********
package com.github.dbchar.zoomapi.utils.services;

import com.github.dbchar.zoomapi.models.Message;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.List;
import java.util.function.BiConsumer;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class MonitorTaskAddOnMessageReceivedListenerTest {
    private MonitorTask monitorTask;
    private BiConsumer<String, Message> listener;
    private Message mockMessage;

    @Before
    public void setUp() {
        monitorTask = Mockito.mock(MonitorTask.class, Mockito.CALLS_REAL_METHODS);
        listener = Mockito.mock(BiConsumer.class);
        mockMessage = Mockito.mock(Message.class);
    }

    @Test
    public void addValidOnMessageReceivedListener() {
        monitorTask.addOnMessageReceivedListener(listener);
        List<BiConsumer<String, Message>> listeners = monitorTask.onMessageReceivedListeners;
        assertTrue(listeners.contains(listener));
    }

    @Test
    public void ignoreNullOnMessageReceivedListener() {
        int initialSize = monitorTask.onMessageReceivedListeners.size();
        monitorTask.addOnMessageReceivedListener(null);
        assertEquals(initialSize, monitorTask.onMessageReceivedListeners.size());
    }

    @Test
    public void addListenerWhenCollectionIsEmpty() {
        monitorTask.onMessageReceivedListeners.clear();
        monitorTask.addOnMessageReceivedListener(listener);
        assertEquals(1, monitorTask.onMessageReceivedListeners.size());
    }

    @Test
    public void addMultipleOnMessageReceivedListeners() {
        BiConsumer<String, Message> secondListener = Mockito.mock(BiConsumer.class);
        monitorTask.addOnMessageReceivedListener(listener);
        monitorTask.addOnMessageReceivedListener(secondListener);
        List<BiConsumer<String, Message>> listeners = monitorTask.onMessageReceivedListeners;
        assertTrue(listeners.contains(listener) && listeners.contains(secondListener));
        assertEquals(2, listeners.size());
    }

    @Test
    public void addSameListenerMultipleTimes() {
        monitorTask.addOnMessageReceivedListener(listener);
        monitorTask.addOnMessageReceivedListener(listener);
        List<BiConsumer<String, Message>> listeners = monitorTask.onMessageReceivedListeners;
        assertTrue(listeners.size() > 1 && listeners.get(0) == listener && listeners.get(1) == listener);
    }
}
