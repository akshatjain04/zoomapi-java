// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=addOnMessageUpdatedListener_f5fdd6fb1e
ROOST_METHOD_SIG_HASH=addOnMessageUpdatedListener_c2d5ab8f7f

================================VULNERABILITIES================================
Vulnerability: CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')
Issue: If the 'Message' object contains user-supplied data and is used in generating web pages without proper encoding, it could lead to XSS attacks.
Solution: Ensure that any user-supplied data in 'Message' objects is properly encoded before being rendered on web pages. Use context-aware escaping libraries to mitigate XSS.

Vulnerability: CWE-20: Improper Input Validation
Issue: The lack of validation for the 'listener' parameter in 'addOnMessageUpdatedListener' method could lead to the execution of unintended code if the listener is maliciously crafted.
Solution: Validate the 'listener' parameter to ensure it conforms to expected types and patterns before adding it to the 'onMessageUpdatedListeners' collection.

Vulnerability: CWE-499: Publicly Exposed Internal Component
Issue: If the 'addOnMessageUpdatedListener' method is publicly exposed without access controls, it may allow attackers to register listeners and potentially intercept sensitive message content.
Solution: Implement proper access controls to restrict the use of 'addOnMessageUpdatedListener' to authorized users or components only.

Vulnerability: CWE-200: Information Exposure
Issue: Passing sensitive message content to external listeners without ensuring confidentiality can lead to information disclosure.
Solution: Apply encryption to sensitive data before passing it to listeners, or ensure that listeners are trusted and have confidentiality agreements.

Vulnerability: CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes
Issue: The method 'addOnMessageUpdatedListener' adds listeners to a collection without verifying the integrity of the objects, which could lead to unauthorized object modification.
Solution: Implement integrity checks or immutable objects to prevent unintended modifications to the objects in the 'onMessageUpdatedListeners' collection.

================================================================================
Scenario 1: Valid listener addition

Details:
  TestName: addValidOnMessageUpdatedListener
  Description: This test checks if a valid listener can be added to the onMessageUpdatedListeners collection.
Execution:
  Arrange: Create a mock BiConsumer<String, Message> listener.
  Act: Invoke the addOnMessageUpdatedListener method with the mock listener.
  Assert: Confirm that the listener has been added to the onMessageUpdatedListeners collection.
Validation:
  The assertion verifies that the listener is present in the collection, ensuring that the method correctly handles valid listener additions. This is significant as it confirms that the message update notification mechanism is functional.

Scenario 2: Null listener handling

Details:
  TestName: ignoreNullOnMessageUpdatedListener
  Description: This test ensures that a null listener is not added to the onMessageUpdatedListeners collection.
Execution:
  Arrange: Set the listener parameter to null.
  Act: Invoke the addOnMessageUpdatedListener method with a null listener.
  Assert: Ensure the onMessageUpdatedListeners collection remains unchanged.
Validation:
  The assertion checks that the collection does not change, which is important to confirm that the method correctly handles null inputs without causing side effects.

Scenario 3: Duplicate listener addition

Details:
  TestName: addDuplicateOnMessageUpdatedListener
  Description: This test checks the behavior when a duplicate listener is added to the onMessageUpdatedListeners collection.
Execution:
  Arrange: Create a mock BiConsumer<String, Message> listener and add it to the collection. Then add the same listener again.
  Act: Invoke the addOnMessageUpdatedListener method twice with the same listener.
  Assert: Ensure that the listener is added only once to the onMessageUpdatedListeners collection.
Validation:
  The assertion ensures that the collection appropriately handles duplicates. This is significant as it prevents unnecessary multiple notifications to the same listener and maintains the integrity of the listener list.

Scenario 4: Multiple listeners addition

Details:
  TestName: addMultipleOnMessageUpdatedListeners
  Description: This test checks if multiple distinct listeners can be added to the onMessageUpdatedListeners collection.
Execution:
  Arrange: Create multiple mock BiConsumer<String, Message> listeners.
  Act: Invoke the addOnMessageUpdatedListener method with each distinct listener.
  Assert: Confirm that all listeners have been added to the onMessageUpdatedListeners collection.
Validation:
  The assertion verifies that each distinct listener is added, ensuring the method can handle multiple listener registrations. This is significant to confirm that the system can notify multiple subscribers of message updates.

Scenario 5: Concurrency handling when adding listeners

Details:
  TestName: addOnMessageUpdatedListenerWithConcurrency
  Description: This test ensures that the addOnMessageUpdatedListener method can handle concurrent attempts to add listeners.
Execution:
  Arrange: Create multiple mock BiConsumer<String, Message> listeners and multiple threads that try to add them concurrently.
  Act: Start all threads and invoke the addOnMessageUpdatedListener method concurrently.
  Assert: Check that all listeners have been added to the onMessageUpdatedListeners collection without any duplicates or omissions.
Validation:
  The assertion checks that the collection correctly handles concurrent additions, which is significant for thread safety and ensuring consistent behavior under concurrent usage scenarios.
*/

// ********RoostGPT********
package com.github.dbchar.zoomapi.utils.services;

import com.github.dbchar.zoomapi.clients.OAuthZoomClient;
import com.github.dbchar.zoomapi.models.Message;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;

import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.mock;

public class MonitorTaskAddOnMessageUpdatedListenerTest {

    private MonitorTask monitorTask;
    private OAuthZoomClient mockClient;

    @Before
    public void setUp() {
        mockClient = mock(OAuthZoomClient.class);
        monitorTask = new MonitorTask("testChannel", "2020-01-01", "2020-12-31", mockClient);
    }

    @Test
    public void addValidOnMessageUpdatedListener() {
        BiConsumer<String, Message> listener = (channel, message) -> {};
        monitorTask.addOnMessageUpdatedListener(listener);
        assertTrue(monitorTask.onMessageUpdatedListeners.contains(listener));
    }

    @Test
    public void ignoreNullOnMessageUpdatedListener() {
        int initialSize = monitorTask.onMessageUpdatedListeners.size();
        monitorTask.addOnMessageUpdatedListener(null);
        assertTrue(monitorTask.onMessageUpdatedListeners.size() == initialSize);
    }

    @Test
    public void addDuplicateOnMessageUpdatedListener() {
        BiConsumer<String, Message> listener = (channel, message) -> {};
        monitorTask.addOnMessageUpdatedListener(listener);
        monitorTask.addOnMessageUpdatedListener(listener);
        assertTrue(monitorTask.onMessageUpdatedListeners.size() == 1);
    }

    @Test
    public void addMultipleOnMessageUpdatedListeners() {
        BiConsumer<String, Message> listener1 = (channel, message) -> {};
        BiConsumer<String, Message> listener2 = (channel, message) -> {};
        monitorTask.addOnMessageUpdatedListener(listener1);
        monitorTask.addOnMessageUpdatedListener(listener2);
        List<BiConsumer<String, Message>> expectedListeners = new ArrayList<>();
        expectedListeners.add(listener1);
        expectedListeners.add(listener2);
        assertTrue(monitorTask.onMessageUpdatedListeners.containsAll(expectedListeners));
    }

    @Test
    public void addOnMessageUpdatedListenerWithConcurrency() throws InterruptedException {
        List<BiConsumer<String, Message>> listenersToAdd = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            BiConsumer<String, Message> listener = (channel, message) -> {};
            listenersToAdd.add(listener);
        }

        Thread[] threads = new Thread[listenersToAdd.size()];
        for (int i = 0; i < listenersToAdd.size(); i++) {
            BiConsumer<String, Message> listener = listenersToAdd.get(i);
            threads[i] = new Thread(() -> monitorTask.addOnMessageUpdatedListener(listener));
            threads[i].start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        assertTrue(monitorTask.onMessageUpdatedListeners.containsAll(listenersToAdd));
    }
}
