// ********RoostGPT********
/*
Test generated by RoostGPT for test MiniProjects using AI Type Open AI and AI Model gpt-4-1106-preview

ROOST_METHOD_HASH=addOnMemberAddedListener_8dd9cbec43
ROOST_METHOD_SIG_HASH=addOnMemberAddedListener_a7d6a523ae

================================VULNERABILITIES================================
Vulnerability: Insecure Direct Object References (IDOR)
Issue: The addOnMemberAddedListener method allows for the registration of a listener that receives User objects. If the User object contains sensitive information, it could be exposed to unauthorized parties if the listener is not properly secured.
Solution: Ensure that the User object does not include sensitive information or implement proper access controls before sending the object to the listener.

Vulnerability: Improper Input Validation
Issue: The listener added via addOnMemberAddedListener is not validated. An attacker could potentially add a malicious listener that performs unwanted actions when triggered.
Solution: Implement validation checks for the listeners being registered. Ensure that only trusted code is allowed to register listeners, and possibly use a security manager to grant or revoke permissions dynamically.

Vulnerability: Use of Potentially Dangerous Function
Issue: The use of third-party libraries (OAuthZoomClient, SQLiteManager, etc.) without proper validation or security checks can introduce vulnerabilities if the libraries are outdated or misconfigured.
Solution: Regularly update third-party libraries to the latest versions, audit their security, and ensure they are used in a safe manner according to their documentation. Additionally, use dependency checking tools to identify known vulnerabilities in these libraries.

Vulnerability: Information Disclosure
Issue: The Logger utility might log sensitive information such as user data or system details, which can be exploited if logs are not handled securely.
Solution: Implement proper log sanitization and management. Avoid logging sensitive information and ensure that log files are stored securely with restricted access.

Vulnerability: Static Imports Misuse
Issue: The code uses static imports, which could lead to namespace conflicts and unintentional method calls, potentially leading to security issues if sensitive methods are accessed.
Solution: Use static imports cautiously and only when it makes the code more readable and does not introduce ambiguity. Always fully qualify critical method calls to prevent namespace conflicts.

Vulnerability: Missing Access Modifiers
Issue: The addOnMemberAddedListener method does not specify an access modifier, which means it has default (package-private) access. This could be a vulnerability if not intended, as it would allow any class in the same package to add listeners.
Solution: Explicitly define the access level (public, protected, private) for methods to ensure that they are not unintentionally exposed to other classes within the same package or to subclasses.

================================================================================
Scenario 1: Valid listener addition

Details:
  TestName: addValidOnMemberAddedListener
  Description: This test checks if a valid listener can be added successfully to the onMemberAddedListeners collection.
Execution:
  Arrange: Create a mock BiConsumer<String, User> listener.
  Act: Call the addOnMemberAddedListener method with the created listener.
  Assert: Assert that the onMemberAddedListeners collection contains the added listener.
Validation:
  The assertion verifies that a valid listener is correctly added to the collection. This test is significant to ensure that the method can handle typical use cases where a consumer is provided to handle member addition events.

Scenario 2: Null listener handling

Details:
  TestName: ignoreNullOnMemberAddedListener
  Description: This test verifies that a null listener is not added to the onMemberAddedListeners collection and does not cause any exceptions.
Execution:
  Arrange: Define a null BiConsumer<String, User> listener.
  Act: Call the addOnMemberAddedListener method with the null listener.
  Assert: Assert that the onMemberAddedListeners collection size remains unchanged.
Validation:
  The assertion checks that the method correctly ignores a null input without altering the state of the listener collection. This test is crucial for validating the method's robustness and its ability to handle edge cases gracefully.

Scenario 3: Listener addition when collection is already populated

Details:
  TestName: addOnMemberAddedListenerWhenAlreadyPopulated
  Description: This test checks if a new listener can be added to the onMemberAddedListeners collection when it already contains other listeners.
Execution:
  Arrange: Create and add some mock BiConsumer<String, User> listeners to the onMemberAddedListeners collection. Then create another listener to be added.
  Act: Call the addOnMemberAddedListener method with the new listener.
  Assert: Assert that the onMemberAddedListeners collection contains the new listener and that its size has increased by one.
Validation:
  The assertion ensures that the method works correctly when adding additional listeners to an already populated collection. This test is significant to ensure that the method can handle multiple listeners and maintain a proper list of registered consumers.

Scenario 4: Duplicate listener addition

Details:
  TestName: addDuplicateOnMemberAddedListener
  Description: This test checks the behavior when attempting to add a duplicate listener to the onMemberAddedListeners collection.
Execution:
  Arrange: Create a mock BiConsumer<String, User> listener and add it to the onMemberAddedListeners collection. Attempt to add the same listener again.
  Act: Call the addOnMemberAddedListener method with the same listener twice.
  Assert: Assert that the onMemberAddedListeners collection only contains one instance of the listener and that its size has not increased after the second addition.
Validation:
  The assertion verifies that duplicate listeners are not added to the collection, assuming the underlying collection implementation prevents duplicates. This test is significant to ensure that the method maintains a unique set of listeners and avoids unnecessary redundancy.
*/

// ********RoostGPT********
package com.github.dbchar.zoomapi.utils.services;

import com.github.dbchar.zoomapi.clients.OAuthZoomClient;
import com.github.dbchar.zoomapi.models.Message;
import com.github.dbchar.zoomapi.models.User;
import com.github.dbchar.zoomapi.utils.MonitorTask;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

import java.util.List;
import java.util.function.BiConsumer;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

public class MonitorTaskAddOnMemberAddedListenerTest {

    private MonitorTask monitorTask;
    private BiConsumer<String, User> listener;
    private BiConsumer<String, User> secondListener;
    
    @Before
    public void setUp() {
        OAuthZoomClient mockClient = mock(OAuthZoomClient.class);
        monitorTask = new MonitorTask("testChannel", "2023-01-01", "2023-12-31", mockClient);
        listener = (channelName, user) -> {};
        secondListener = (channelName, user) -> {};
    }

    @Test
    public void addValidOnMemberAddedListener() {
        monitorTask.addOnMemberAddedListener(listener);
        List<BiConsumer<String, User>> listeners = monitorTask.onMemberAddedListeners;
        assertTrue(listeners.contains(listener));
    }

    @Test
    public void ignoreNullOnMemberAddedListener() {
        int initialSize = monitorTask.onMemberAddedListeners.size();
        monitorTask.addOnMemberAddedListener(null);
        assertEquals(initialSize, monitorTask.onMemberAddedListeners.size());
    }

    @Test
    public void addOnMemberAddedListenerWhenAlreadyPopulated() {
        monitorTask.addOnMemberAddedListener(listener);
        int initialSize = monitorTask.onMemberAddedListeners.size();
        monitorTask.addOnMemberAddedListener(secondListener);
        assertEquals(initialSize + 1, monitorTask.onMemberAddedListeners.size());
        assertTrue(monitorTask.onMemberAddedListeners.contains(secondListener));
    }

    @Test
    public void addDuplicateOnMemberAddedListener() {
        monitorTask.addOnMemberAddedListener(listener);
        int initialSize = monitorTask.onMemberAddedListeners.size();
        monitorTask.addOnMemberAddedListener(listener);
        assertEquals(initialSize, monitorTask.onMemberAddedListeners.size());
        assertEquals(1, monitorTask.onMemberAddedListeners.stream().filter(l -> l == listener).count());
    }
}
